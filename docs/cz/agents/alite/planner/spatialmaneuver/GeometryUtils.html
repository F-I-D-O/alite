<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_13) on Fri May 07 14:21:11 CEST 2010 -->
<TITLE>
GeometryUtils
</TITLE>

<META NAME="date" CONTENT="2010-05-07">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GeometryUtils";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GeometryUtils.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/DebugTextZoneVisitor.html" title="class in cz.agents.alite.planner.spatialmaneuver"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.AntiClockWiseComparator.html" title="class in cz.agents.alite.planner.spatialmaneuver"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GeometryUtils.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
cz.agents.alite.planner.spatialmaneuver</FONT>
<BR>
Class GeometryUtils</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../../../resources/inherit.gif" ALT="extended by "><B>cz.agents.alite.planner.spatialmaneuver.GeometryUtils</B>
</PRE>
<HR>
<DL>
<DT><PRE>public final class <B>GeometryUtils</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
Collection of geometry utility methods. All methods are static.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD><a href="mailto:jacob.dreyer@geosoft.no">Jacob Dreyer</a></DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->

<A NAME="nested_class_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Nested Class Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.AntiClockWiseComparator.html" title="class in cz.agents.alite.planner.spatialmaneuver">GeometryUtils.AntiClockWiseComparator</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;class</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.Arc.html" title="class in cz.agents.alite.planner.spatialmaneuver">GeometryUtils.Arc</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#GeometryUtils()">GeometryUtils</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List&lt;double[]&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#allIntersectionsOfRectangleAndCircle(double, double, double, double, double, double, double)">allIntersectionsOfRectangleAndCircle</A></B>(double&nbsp;x1,
                                     double&nbsp;y1,
                                     double&nbsp;x2,
                                     double&nbsp;y2,
                                     double&nbsp;xCirc,
                                     double&nbsp;yCirc,
                                     double&nbsp;rCirc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#angleBetweenVectors(double, double, double, double)">angleBetweenVectors</A></B>(double&nbsp;fx,
                    double&nbsp;fy,
                    double&nbsp;tx,
                    double&nbsp;ty)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#angleFromCoords(double[])">angleFromCoords</A></B>(double[]&nbsp;p)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#angleFromCoords(double, double)">angleFromCoords</A></B>(double&nbsp;x,
                double&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#angleFromThreePoints(javax.vecmath.Point3d, javax.vecmath.Point3d, javax.vecmath.Point3d)">angleFromThreePoints</A></B>(javax.vecmath.Point3d&nbsp;apex,
                     javax.vecmath.Point3d&nbsp;from,
                     javax.vecmath.Point3d&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#angleFromTwoPoints(javax.vecmath.Point3d, javax.vecmath.Point3d)">angleFromTwoPoints</A></B>(javax.vecmath.Point3d&nbsp;from,
                   javax.vecmath.Point3d&nbsp;to)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns an angle of a vector = to - from</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List&lt;java.lang.Double&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#circleIntersectionWithHorizontalLine(double, double, double, double)">circleIntersectionWithHorizontalLine</A></B>(double&nbsp;yLine,
                                     double&nbsp;xCircleCenter,
                                     double&nbsp;yCircleCenter,
                                     double&nbsp;circleRadius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List&lt;java.lang.Double&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#circleIntersectionWithLineSegment(double, double, double, double, double, double, double)">circleIntersectionWithLineSegment</A></B>(double&nbsp;x1,
                                  double&nbsp;y1,
                                  double&nbsp;x2,
                                  double&nbsp;y2,
                                  double&nbsp;xCirc,
                                  double&nbsp;yCirc,
                                  double&nbsp;rCirc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only intersection with segments that are oriented along x or y axis.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List&lt;java.lang.Double&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#circleIntersectionWithVerticalLine(double, double, double, double)">circleIntersectionWithVerticalLine</A></B>(double&nbsp;xLine,
                                   double&nbsp;xCircleCenter,
                                   double&nbsp;yCircleCenter,
                                   double&nbsp;circleRadius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List&lt;java.lang.Double&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#circleLineIntersection(double, double, double, double)">circleLineIntersection</A></B>(double&nbsp;lineConst,
                       double&nbsp;circleCenter1,
                       double&nbsp;circleCenter2,
                       double&nbsp;circleRadius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computeAngle(double[], double[], double[])">computeAngle</A></B>(double[]&nbsp;p0,
             double[]&nbsp;p1,
             double[]&nbsp;p2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the angle between twree points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computeCrossProduct(double[], double[])">computeCrossProduct</A></B>(double[]&nbsp;v0,
                    double[]&nbsp;v1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the cross product (a vector) of two vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computeDotProduct(double[], double[])">computeDotProduct</A></B>(double[]&nbsp;v0,
                  double[]&nbsp;v1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the dot product (a scalar) between two vectors.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computePointOnLine(double[], double[], double)">computePointOnLine</A></B>(double[]&nbsp;p0,
                   double[]&nbsp;p1,
                   double&nbsp;fractionFromP0)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the point on the line p0,p1 [x,y,z] a given fraction from p0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computePointOnLine(double, double, double, double, double)">computePointOnLine</A></B>(double&nbsp;x0,
                   double&nbsp;y0,
                   double&nbsp;x1,
                   double&nbsp;y1,
                   double&nbsp;fractionFrom0)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the point on the line defined by x0,y0,x1,y1 a given fraction
 from x0,y0. 2D version of method above..</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computePolygonArea(double[])">computePolygonArea</A></B>(double[]&nbsp;xy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the area of the specfied polygon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computePolygonArea(double[], double[])">computePolygonArea</A></B>(double[]&nbsp;x,
                   double[]&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the area of the specfied polygon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#computePolygonCentroid(double[], double[])">computePolygonCentroid</A></B>(double[]&nbsp;x,
                       double[]&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute centorid (center of gravity) of specified polygon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createArrow(int[], int[], double, double, double)">createArrow</A></B>(int[]&nbsp;x,
            int[]&nbsp;y,
            double&nbsp;length,
            double&nbsp;angle,
            double&nbsp;inset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the geometry of an arrow.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createArrow(int, int, int, int, double, double, double)">createArrow</A></B>(int&nbsp;x0,
            int&nbsp;y0,
            int&nbsp;x1,
            int&nbsp;y1,
            double&nbsp;length,
            double&nbsp;angle,
            double&nbsp;inset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create geometry for an arrow along the specified line and with
 tip at x1,y1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createCircle(double, double, double)">createCircle</A></B>(double&nbsp;x0,
             double&nbsp;y0,
             double&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create geometry for a circle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createCircle(int, int, int)">createCircle</A></B>(int&nbsp;x0,
             int&nbsp;y0,
             int&nbsp;radius)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create geometry for a circle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createEllipse(double, double, double, double)">createEllipse</A></B>(double&nbsp;x0,
              double&nbsp;y0,
              double&nbsp;dx,
              double&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the geometry for an unrotated, unskewed ellipse.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createEllipse(int[], int[])">createEllipse</A></B>(int[]&nbsp;x,
              int[]&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the geometry of an ellipse based on its four top points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createEllipse(int, int, int, int)">createEllipse</A></B>(int&nbsp;x0,
              int&nbsp;y0,
              int&nbsp;dx,
              int&nbsp;dy)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the geometry for an unrotated, unskewed ellipse.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createRectangle(double, double, double, double)">createRectangle</A></B>(double&nbsp;x0,
                double&nbsp;y0,
                double&nbsp;width,
                double&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create geometry for a rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createRectangle(int, int, int, int)">createRectangle</A></B>(int&nbsp;x0,
                int&nbsp;y0,
                int&nbsp;width,
                int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create geometry for a rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createSector(int, int, int, double, double)">createSector</A></B>(int&nbsp;x0,
             int&nbsp;y0,
             int&nbsp;radius,
             double&nbsp;angle0,
             double&nbsp;angle1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the geometry of a sector of a circle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createSector(int, int, int, int, double, double)">createSector</A></B>(int&nbsp;x0,
             int&nbsp;y0,
             int&nbsp;dx,
             int&nbsp;dy,
             double&nbsp;angle0,
             double&nbsp;angle1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create the geometry of a sector of an ellipse.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createStar(double, double, double, double, int)">createStar</A></B>(double&nbsp;x0,
           double&nbsp;y0,
           double&nbsp;innerRadius,
           double&nbsp;outerRadius,
           int&nbsp;nArms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create geometry of a star.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createStar(int, int, int, int, int)">createStar</A></B>(int&nbsp;x0,
           int&nbsp;y0,
           int&nbsp;innerRadius,
           int&nbsp;outerRadius,
           int&nbsp;nArms)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Create geometry of a star.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#createVector(double[], double[])">createVector</A></B>(double[]&nbsp;p0,
             double[]&nbsp;p1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct the vector specified by two points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#distance(int, int, int, int, int, int)">distance</A></B>(int&nbsp;x0,
         int&nbsp;y0,
         int&nbsp;x1,
         int&nbsp;y1,
         int&nbsp;x,
         int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return distance bwetween the line defined by (x0,y0) and (x1,y1)
 and the point (x,y).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#extendLine(double[], double[], double)">extendLine</A></B>(double[]&nbsp;p0,
           double[]&nbsp;p1,
           double&nbsp;toLength)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extend a given line segment to a given length and holding the first
 point of the line as fixed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#extendLine(double[], double[], double, double)">extendLine</A></B>(double[]&nbsp;p0,
           double[]&nbsp;p1,
           double&nbsp;toLength,
           double&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Extend a given line segment to a specified length.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#findLinePolygonIntersections(double[], double[], double, double, double, double)">findLinePolygonIntersections</A></B>(double[]&nbsp;x,
                             double[]&nbsp;y,
                             double&nbsp;x0,
                             double&nbsp;y0,
                             double&nbsp;x1,
                             double&nbsp;y1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the intersections between a polygon and a straight line.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#findLineSegmentIntersection(double, double, double, double, double, double, double, double, double[])">findLineSegmentIntersection</A></B>(double&nbsp;x0,
                            double&nbsp;y0,
                            double&nbsp;x1,
                            double&nbsp;y1,
                            double&nbsp;x2,
                            double&nbsp;y2,
                            double&nbsp;x3,
                            double&nbsp;y3,
                            double[]&nbsp;intersection)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the intersection between two line segments, or two lines
 of infinite length.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#findPolygonExtent(double[], double[], double[], double[], double[], double[])">findPolygonExtent</A></B>(double[]&nbsp;x,
                  double[]&nbsp;y,
                  double[]&nbsp;z,
                  double[]&nbsp;xExtent,
                  double[]&nbsp;yExtent,
                  double[]&nbsp;zExtent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the 3D extent of a polyline.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#findPolygonExtent(int[], int[], int[], int[])">findPolygonExtent</A></B>(int[]&nbsp;x,
                  int[]&nbsp;y,
                  int[]&nbsp;xExtent,
                  int[]&nbsp;yExtent)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Find the extent of a polygon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#findPolygonPosition(int[], int[], double, int[])">findPolygonPosition</A></B>(int[]&nbsp;x,
                    int[]&nbsp;y,
                    double&nbsp;length,
                    int[]&nbsp;position)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the x,y position at distance "length" into the given polyline.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.util.List&lt;<A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.Arc.html" title="class in cz.agents.alite.planner.spatialmaneuver">GeometryUtils.Arc</A>&gt;</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#getArcsOfCircleInsideRectangle(double, double, double, double, double, double, double)">getArcsOfCircleInsideRectangle</A></B>(double&nbsp;x1,
                               double&nbsp;y1,
                               double&nbsp;x2,
                               double&nbsp;y2,
                               double&nbsp;xCirc,
                               double&nbsp;yCirc,
                               double&nbsp;rCirc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isArc(double[], double[], double, double, double, double, double, double, double)">isArc</A></B>(double[]&nbsp;firstPoint,
      double[]&nbsp;secondPoint,
      double&nbsp;x1,
      double&nbsp;y1,
      double&nbsp;x2,
      double&nbsp;y2,
      double&nbsp;xCirc,
      double&nbsp;yCirc,
      double&nbsp;rCirc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;first point is assumed to be less anticlockwise than the second point</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isCircleInsideRectangle(double, double, double, double, double, double, double)">isCircleInsideRectangle</A></B>(double&nbsp;x1,
                        double&nbsp;y1,
                        double&nbsp;x2,
                        double&nbsp;y2,
                        double&nbsp;xCirc,
                        double&nbsp;yCirc,
                        double&nbsp;rCirc)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isLineIntersectingLine(double, double, double, double, double, double, double, double)">isLineIntersectingLine</A></B>(double&nbsp;x0,
                       double&nbsp;y0,
                       double&nbsp;x1,
                       double&nbsp;y1,
                       double&nbsp;x2,
                       double&nbsp;y2,
                       double&nbsp;x3,
                       double&nbsp;y3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if two line segments intersects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isLineIntersectingLine(int, int, int, int, int, int, int, int)">isLineIntersectingLine</A></B>(int&nbsp;x0,
                       int&nbsp;y0,
                       int&nbsp;x1,
                       int&nbsp;y1,
                       int&nbsp;x2,
                       int&nbsp;y2,
                       int&nbsp;x3,
                       int&nbsp;y3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if two line segments intersects.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isLineIntersectingRectangle(int, int, int, int, int, int, int, int)">isLineIntersectingRectangle</A></B>(int&nbsp;lx0,
                            int&nbsp;ly0,
                            int&nbsp;lx1,
                            int&nbsp;ly1,
                            int&nbsp;x0,
                            int&nbsp;y0,
                            int&nbsp;x1,
                            int&nbsp;y1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if a specified line intersects a specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isPointInsidePolygon(double[], double[], double, double)">isPointInsidePolygon</A></B>(double[]&nbsp;x,
                     double[]&nbsp;y,
                     double&nbsp;pointX,
                     double&nbsp;pointY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if a given point is inside a given (complex) polygon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isPointInsidePolygon(int[], int[], int, int)">isPointInsidePolygon</A></B>(int[]&nbsp;x,
                     int[]&nbsp;y,
                     int&nbsp;pointX,
                     int&nbsp;pointY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if a given point is inside a given polygon.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isPointInsideRectangle(int, int, int, int, int, int)">isPointInsideRectangle</A></B>(int&nbsp;x0,
                       int&nbsp;y0,
                       int&nbsp;x1,
                       int&nbsp;y1,
                       int&nbsp;x,
                       int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if a specified point is inside a specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isPolygonIntersectingRectangle(int[], int[], int, int, int, int)">isPolygonIntersectingRectangle</A></B>(int[]&nbsp;x,
                               int[]&nbsp;y,
                               int&nbsp;x0,
                               int&nbsp;y0,
                               int&nbsp;x1,
                               int&nbsp;y1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if a specified polygon intersects a specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#isPolylineIntersectingRectangle(int[], int[], int, int, int, int)">isPolylineIntersectingRectangle</A></B>(int[]&nbsp;x,
                                int[]&nbsp;y,
                                int&nbsp;x0,
                                int&nbsp;y0,
                                int&nbsp;x1,
                                int&nbsp;y1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if a specified polyline intersects a specified rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#length(double[])">length</A></B>(double[]&nbsp;v)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Return the length of a vector.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#length(double[], double[])">length</A></B>(double[]&nbsp;p0,
       double[]&nbsp;p1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute distance between two points.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#length(double, double, double, double)">length</A></B>(double&nbsp;x0,
       double&nbsp;y0,
       double&nbsp;x1,
       double&nbsp;y1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the length of the line from (x0,y0) to (x1,y1)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#length(int[], int[], boolean)">length</A></B>(int[]&nbsp;x,
       int[]&nbsp;y,
       boolean&nbsp;isClosed)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the length of a polyline.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;double</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#length(int, int, int, int)">length</A></B>(int&nbsp;x0,
       int&nbsp;y0,
       int&nbsp;x1,
       int&nbsp;y1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Compute the length of the line from (x0,y0) to (x1,y1)</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#pointInRectangle(double, double, double, double, double, double)">pointInRectangle</A></B>(double&nbsp;xp,
                 double&nbsp;yp,
                 double&nbsp;x1,
                 double&nbsp;y1,
                 double&nbsp;x2,
                 double&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html#pointInSegment(double, double, double, double, double, double)">pointInSegment</A></B>(double&nbsp;xp,
               double&nbsp;yp,
               double&nbsp;x1,
               double&nbsp;y1,
               double&nbsp;x2,
               double&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Only for segments that are oriented along x or y axis.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GeometryUtils()"><!-- --></A><H3>
GeometryUtils</H3>
<PRE>
public <B>GeometryUtils</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="isPointInsideRectangle(int, int, int, int, int, int)"><!-- --></A><H3>
isPointInsideRectangle</H3>
<PRE>
public static boolean <B>isPointInsideRectangle</B>(int&nbsp;x0,
                                             int&nbsp;y0,
                                             int&nbsp;x1,
                                             int&nbsp;y1,
                                             int&nbsp;x,
                                             int&nbsp;y)</PRE>
<DL>
<DD>Check if a specified point is inside a specified rectangle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0,</CODE> - y0, x1, y1  Upper left and lower right corner of rectangle
                        (inclusive)<DD><CODE>x,y</CODE> - Point to check.
<DT><B>Returns:</B><DD>True if the point is inside the rectangle,
                        false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isPointInsidePolygon(double[], double[], double, double)"><!-- --></A><H3>
isPointInsidePolygon</H3>
<PRE>
public static boolean <B>isPointInsidePolygon</B>(double[]&nbsp;x,
                                           double[]&nbsp;y,
                                           double&nbsp;pointX,
                                           double&nbsp;pointY)</PRE>
<DL>
<DD>Check if a given point is inside a given (complex) polygon.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x,</CODE> - y            Polygon.<DD><CODE>pointX,</CODE> - pointY  Point to check.
<DT><B>Returns:</B><DD>True if the given point is inside the polygon, false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isPointInsidePolygon(int[], int[], int, int)"><!-- --></A><H3>
isPointInsidePolygon</H3>
<PRE>
public static boolean <B>isPointInsidePolygon</B>(int[]&nbsp;x,
                                           int[]&nbsp;y,
                                           int&nbsp;pointX,
                                           int&nbsp;pointY)</PRE>
<DL>
<DD>Check if a given point is inside a given polygon. Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x,</CODE> - y            Polygon.<DD><CODE>pointX,</CODE> - pointY  Point to check.
<DT><B>Returns:</B><DD>True if the given point is inside the polygon, false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="computePointOnLine(double[], double[], double)"><!-- --></A><H3>
computePointOnLine</H3>
<PRE>
public static double[] <B>computePointOnLine</B>(double[]&nbsp;p0,
                                          double[]&nbsp;p1,
                                          double&nbsp;fractionFromP0)</PRE>
<DL>
<DD>Find the point on the line p0,p1 [x,y,z] a given fraction from p0.
 Fraction of 0.0 whould give back p0, 1.0 give back p1, 0.5 returns
 midpoint of line p0,p1 and so on. F
 raction can be >1 and it can be negative to return any point on the
 line specified by p0,p1.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p0</CODE> - First coordinale of line [x,y,z].<DD><CODE>p0</CODE> - Second coordinale of line [x,y,z].<DD><CODE>fractionFromP0</CODE> - Point we are looking for coordinates of<DD><CODE>p</CODE> - Coordinate of point we are looking for</DL>
</DD>
</DL>
<HR>

<A NAME="computePointOnLine(double, double, double, double, double)"><!-- --></A><H3>
computePointOnLine</H3>
<PRE>
public static double[] <B>computePointOnLine</B>(double&nbsp;x0,
                                          double&nbsp;y0,
                                          double&nbsp;x1,
                                          double&nbsp;y1,
                                          double&nbsp;fractionFrom0)</PRE>
<DL>
<DD>Find the point on the line defined by x0,y0,x1,y1 a given fraction
 from x0,y0. 2D version of method above..
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0,</CODE> - y0         First point defining the line<DD><CODE>x1,</CODE> - y1         Second point defining the line<DD><CODE>fractionFrom0</CODE> - Distance from (x0,y0)
<DT><B>Returns:</B><DD>x, y           Coordinate of point we are looking for</DL>
</DD>
</DL>
<HR>

<A NAME="extendLine(double[], double[], double, double)"><!-- --></A><H3>
extendLine</H3>
<PRE>
public static void <B>extendLine</B>(double[]&nbsp;p0,
                              double[]&nbsp;p1,
                              double&nbsp;toLength,
                              double&nbsp;anchor)</PRE>
<DL>
<DD>Extend a given line segment to a specified length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p0,</CODE> - p1    Line segment to extend [x,y,z].<DD><CODE>toLength</CODE> - Length of new line segment.<DD><CODE>anchor</CODE> - Specifies the fixed point during extension.
                  If anchor is 0.0, p0 is fixed and p1 is adjusted.
                  If anchor is 1.0, p1 is fixed and p0 is adjusted.
                  If anchor is 0.5, the line is adjusted equally in each
                  direction and so on.</DL>
</DD>
</DL>
<HR>

<A NAME="extendLine(double[], double[], double)"><!-- --></A><H3>
extendLine</H3>
<PRE>
public static void <B>extendLine</B>(double[]&nbsp;p0,
                              double[]&nbsp;p1,
                              double&nbsp;toLength)</PRE>
<DL>
<DD>Extend a given line segment to a given length and holding the first
 point of the line as fixed.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p0,</CODE> - p1  Line segment to extend. p0 is fixed during extension<DD><CODE>length</CODE> - Length of new line segment.</DL>
</DD>
</DL>
<HR>

<A NAME="length(double[])"><!-- --></A><H3>
length</H3>
<PRE>
public static double <B>length</B>(double[]&nbsp;v)</PRE>
<DL>
<DD>Return the length of a vector.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v</CODE> - Vector to compute length of [x,y,z].
<DT><B>Returns:</B><DD>Length of vector.</DL>
</DD>
</DL>
<HR>

<A NAME="length(double[], double[])"><!-- --></A><H3>
length</H3>
<PRE>
public static double <B>length</B>(double[]&nbsp;p0,
                            double[]&nbsp;p1)</PRE>
<DL>
<DD>Compute distance between two points.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p0,</CODE> - p1  Points to compute distance between [x,y,z].
<DT><B>Returns:</B><DD>Distance between points.</DL>
</DD>
</DL>
<HR>

<A NAME="length(int, int, int, int)"><!-- --></A><H3>
length</H3>
<PRE>
public static double <B>length</B>(int&nbsp;x0,
                            int&nbsp;y0,
                            int&nbsp;x1,
                            int&nbsp;y1)</PRE>
<DL>
<DD>Compute the length of the line from (x0,y0) to (x1,y1)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0,</CODE> - y0  First line end point.<DD><CODE>x1,</CODE> - y1  Second line end point.
<DT><B>Returns:</B><DD>Length of line from (x0,y0) to (x1,y1).</DL>
</DD>
</DL>
<HR>

<A NAME="length(double, double, double, double)"><!-- --></A><H3>
length</H3>
<PRE>
public static double <B>length</B>(double&nbsp;x0,
                            double&nbsp;y0,
                            double&nbsp;x1,
                            double&nbsp;y1)</PRE>
<DL>
<DD>Compute the length of the line from (x0,y0) to (x1,y1)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0,</CODE> - y0  First line end point.<DD><CODE>x1,</CODE> - y1  Second line end point.
<DT><B>Returns:</B><DD>Length of line from (x0,y0) to (x1,y1).</DL>
</DD>
</DL>
<HR>

<A NAME="length(int[], int[], boolean)"><!-- --></A><H3>
length</H3>
<PRE>
public static double <B>length</B>(int[]&nbsp;x,
                            int[]&nbsp;y,
                            boolean&nbsp;isClosed)</PRE>
<DL>
<DD>Compute the length of a polyline.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x,</CODE> - y     Arrays of x,y coordinates<DD><CODE>nPoints</CODE> - Number of elements in the above.<DD><CODE>isClosed</CODE> - True if this is a closed polygon, false otherwise
<DT><B>Returns:</B><DD>Length of polyline defined by x, y and nPoints.</DL>
</DD>
</DL>
<HR>

<A NAME="distance(int, int, int, int, int, int)"><!-- --></A><H3>
distance</H3>
<PRE>
public static double <B>distance</B>(int&nbsp;x0,
                              int&nbsp;y0,
                              int&nbsp;x1,
                              int&nbsp;y1,
                              int&nbsp;x,
                              int&nbsp;y)</PRE>
<DL>
<DD>Return distance bwetween the line defined by (x0,y0) and (x1,y1)
 and the point (x,y).
 Ref: http://astronomy.swin.edu.au/pbourke/geometry/pointline/
 The 3D case should be similar.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0,</CODE> - y0  First point of line.<DD><CODE>x1,</CODE> - y1  Second point of line.<DD><CODE>x,</CODE> - y,   Point to consider.
<DT><B>Returns:</B><DD>Distance from x,y down to the (extended) line defined
                 by x0, y0, x1, y1.</DL>
</DD>
</DL>
<HR>

<A NAME="computeAngle(double[], double[], double[])"><!-- --></A><H3>
computeAngle</H3>
<PRE>
public static double <B>computeAngle</B>(double[]&nbsp;p0,
                                  double[]&nbsp;p1,
                                  double[]&nbsp;p2)</PRE>
<DL>
<DD>Find the angle between twree points. P0 is center point
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p0,</CODE> - p1, p2  Three points finding angle between [x,y,z].
<DT><B>Returns:</B><DD>Angle (in radians) between given points.</DL>
</DD>
</DL>
<HR>

<A NAME="computeDotProduct(double[], double[])"><!-- --></A><H3>
computeDotProduct</H3>
<PRE>
public static double <B>computeDotProduct</B>(double[]&nbsp;v0,
                                       double[]&nbsp;v1)</PRE>
<DL>
<DD>Compute the dot product (a scalar) between two vectors.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v0,</CODE> - v1  Vectors to compute dot product between [x,y,z].
<DT><B>Returns:</B><DD>Dot product of given vectors.</DL>
</DD>
</DL>
<HR>

<A NAME="computeCrossProduct(double[], double[])"><!-- --></A><H3>
computeCrossProduct</H3>
<PRE>
public static double[] <B>computeCrossProduct</B>(double[]&nbsp;v0,
                                           double[]&nbsp;v1)</PRE>
<DL>
<DD>Compute the cross product (a vector) of two vectors.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>v0,</CODE> - v1        Vectors to compute cross product between [x,y,z].<DD><CODE>crossProduct</CODE> - Cross product of specified vectors [x,y,z].</DL>
</DD>
</DL>
<HR>

<A NAME="createVector(double[], double[])"><!-- --></A><H3>
createVector</H3>
<PRE>
public static double[] <B>createVector</B>(double[]&nbsp;p0,
                                    double[]&nbsp;p1)</PRE>
<DL>
<DD>Construct the vector specified by two points.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p0,</CODE> - p1  Points the construct vector between [x,y,z].
<DT><B>Returns:</B><DD>v       Vector from p0 to p1 [x,y,z].</DL>
</DD>
</DL>
<HR>

<A NAME="isLineIntersectingLine(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
isLineIntersectingLine</H3>
<PRE>
public static boolean <B>isLineIntersectingLine</B>(int&nbsp;x0,
                                             int&nbsp;y0,
                                             int&nbsp;x1,
                                             int&nbsp;y1,
                                             int&nbsp;x2,
                                             int&nbsp;y2,
                                             int&nbsp;x3,
                                             int&nbsp;y3)</PRE>
<DL>
<DD>Check if two line segments intersects. Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0,</CODE> - y0, x1, y1  End points of first line to check.<DD><CODE>x2,</CODE> - yy, x3, y3  End points of second line to check.
<DT><B>Returns:</B><DD>True if the two lines intersects.</DL>
</DD>
</DL>
<HR>

<A NAME="isLineIntersectingLine(double, double, double, double, double, double, double, double)"><!-- --></A><H3>
isLineIntersectingLine</H3>
<PRE>
public static boolean <B>isLineIntersectingLine</B>(double&nbsp;x0,
                                             double&nbsp;y0,
                                             double&nbsp;x1,
                                             double&nbsp;y1,
                                             double&nbsp;x2,
                                             double&nbsp;y2,
                                             double&nbsp;x3,
                                             double&nbsp;y3)</PRE>
<DL>
<DD>Check if two line segments intersects. Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0,</CODE> - y0, x1, y1  End points of first line to check.<DD><CODE>x2,</CODE> - yy, x3, y3  End points of second line to check.
<DT><B>Returns:</B><DD>True if the two lines intersects.</DL>
</DD>
</DL>
<HR>

<A NAME="isLineIntersectingRectangle(int, int, int, int, int, int, int, int)"><!-- --></A><H3>
isLineIntersectingRectangle</H3>
<PRE>
public static boolean <B>isLineIntersectingRectangle</B>(int&nbsp;lx0,
                                                  int&nbsp;ly0,
                                                  int&nbsp;lx1,
                                                  int&nbsp;ly1,
                                                  int&nbsp;x0,
                                                  int&nbsp;y0,
                                                  int&nbsp;x1,
                                                  int&nbsp;y1)</PRE>
<DL>
<DD>Check if a specified line intersects a specified rectangle.
 Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>lx0,</CODE> - ly0        1st end point of line<DD><CODE>ly1,</CODE> - ly1        2nd end point of line<DD><CODE>x0,</CODE> - y0, x1, y1  Upper left and lower right corner of rectangle
                        (inclusive).
<DT><B>Returns:</B><DD>True if the line intersects the rectangle,
                        false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isPolylineIntersectingRectangle(int[], int[], int, int, int, int)"><!-- --></A><H3>
isPolylineIntersectingRectangle</H3>
<PRE>
public static boolean <B>isPolylineIntersectingRectangle</B>(int[]&nbsp;x,
                                                      int[]&nbsp;y,
                                                      int&nbsp;x0,
                                                      int&nbsp;y0,
                                                      int&nbsp;x1,
                                                      int&nbsp;y1)</PRE>
<DL>
<DD>Check if a specified polyline intersects a specified rectangle.
 Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x,</CODE> - y            Polyline to check.<DD><CODE>x0,</CODE> - y0, x1, y1  Upper left and lower left corner of rectangle
                        (inclusive).
<DT><B>Returns:</B><DD>True if the polyline intersects the rectangle,
                        false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="isPolygonIntersectingRectangle(int[], int[], int, int, int, int)"><!-- --></A><H3>
isPolygonIntersectingRectangle</H3>
<PRE>
public static boolean <B>isPolygonIntersectingRectangle</B>(int[]&nbsp;x,
                                                     int[]&nbsp;y,
                                                     int&nbsp;x0,
                                                     int&nbsp;y0,
                                                     int&nbsp;x1,
                                                     int&nbsp;y1)</PRE>
<DL>
<DD>Check if a specified polygon intersects a specified rectangle.
 Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polyline.<DD><CODE>y</CODE> - Y coordinates of polyline.<DD><CODE>x0</CODE> - X of upper left corner of rectangle.<DD><CODE>y0</CODE> - Y of upper left corner of rectangle.<DD><CODE>x1</CODE> - X of lower right corner of rectangle.<DD><CODE>y1</CODE> - Y of lower right corner of rectangle.
<DT><B>Returns:</B><DD>True if the polyline intersects the rectangle, false otherwise.</DL>
</DD>
</DL>
<HR>

<A NAME="computePolygonArea(double[], double[])"><!-- --></A><H3>
computePolygonArea</H3>
<PRE>
public static double <B>computePolygonArea</B>(double[]&nbsp;x,
                                        double[]&nbsp;y)</PRE>
<DL>
<DD>Compute the area of the specfied polygon.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polygon.<DD><CODE>y</CODE> - Y coordinates of polygon.
<DT><B>Returns:</B><DD>Area of specified polygon.</DL>
</DD>
</DL>
<HR>

<A NAME="computePolygonArea(double[])"><!-- --></A><H3>
computePolygonArea</H3>
<PRE>
public static double <B>computePolygonArea</B>(double[]&nbsp;xy)</PRE>
<DL>
<DD>Compute the area of the specfied polygon.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xy</CODE> - Geometry of polygon [x,y,...]
<DT><B>Returns:</B><DD>Area of specified polygon.</DL>
</DD>
</DL>
<HR>

<A NAME="computePolygonCentroid(double[], double[])"><!-- --></A><H3>
computePolygonCentroid</H3>
<PRE>
public static double[] <B>computePolygonCentroid</B>(double[]&nbsp;x,
                                              double[]&nbsp;y)</PRE>
<DL>
<DD>Compute centorid (center of gravity) of specified polygon.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polygon.<DD><CODE>y</CODE> - Y coordinates of polygon.
<DT><B>Returns:</B><DD>Centroid [x,y] of specified polygon.</DL>
</DD>
</DL>
<HR>

<A NAME="findPolygonExtent(double[], double[], double[], double[], double[], double[])"><!-- --></A><H3>
findPolygonExtent</H3>
<PRE>
public static void <B>findPolygonExtent</B>(double[]&nbsp;x,
                                     double[]&nbsp;y,
                                     double[]&nbsp;z,
                                     double[]&nbsp;xExtent,
                                     double[]&nbsp;yExtent,
                                     double[]&nbsp;zExtent)</PRE>
<DL>
<DD>Find the 3D extent of a polyline.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polyline.<DD><CODE>y</CODE> - Y coordinates of polyline.<DD><CODE>z</CODE> - Z coordinates of polyline.
                 May be null if this is a 2D case.<DD><CODE>xExtent</CODE> - Will upon return contain [xMin,xMax].<DD><CODE>yExtent</CODE> - Will upon return contain [xMin,xMax].<DD><CODE>zExtent</CODE> - Will upon return contain [xMin,xMax]. Unused (may be
                 set to null) if z is null.</DL>
</DD>
</DL>
<HR>

<A NAME="findPolygonExtent(int[], int[], int[], int[])"><!-- --></A><H3>
findPolygonExtent</H3>
<PRE>
public static void <B>findPolygonExtent</B>(int[]&nbsp;x,
                                     int[]&nbsp;y,
                                     int[]&nbsp;xExtent,
                                     int[]&nbsp;yExtent)</PRE>
<DL>
<DD>Find the extent of a polygon.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polygon.<DD><CODE>y</CODE> - Y coordinates of polygon.<DD><CODE>xExtent</CODE> - Will upon return contain [xMin, xMax]<DD><CODE>yExtent</CODE> - Will upon return contain [yMin, yMax]</DL>
</DD>
</DL>
<HR>

<A NAME="findLineSegmentIntersection(double, double, double, double, double, double, double, double, double[])"><!-- --></A><H3>
findLineSegmentIntersection</H3>
<PRE>
public static int <B>findLineSegmentIntersection</B>(double&nbsp;x0,
                                              double&nbsp;y0,
                                              double&nbsp;x1,
                                              double&nbsp;y1,
                                              double&nbsp;x2,
                                              double&nbsp;y2,
                                              double&nbsp;x3,
                                              double&nbsp;y3,
                                              double[]&nbsp;intersection)</PRE>
<DL>
<DD>Compute the intersection between two line segments, or two lines
 of infinite length.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X coordinate first end point first line segment.<DD><CODE>y0</CODE> - Y coordinate first end point first line segment.<DD><CODE>x1</CODE> - X coordinate second end point first line segment.<DD><CODE>y1</CODE> - Y coordinate second end point first line segment.<DD><CODE>x2</CODE> - X coordinate first end point second line segment.<DD><CODE>y2</CODE> - Y coordinate first end point second line segment.<DD><CODE>x3</CODE> - X coordinate second end point second line segment.<DD><CODE>y3</CODE> - Y coordinate second end point second line segment.<DD><CODE>intersection[2]</CODE> - Preallocated by caller to double[2]
<DT><B>Returns:</B><DD>-1 if lines are parallel (x,y unset),
         -2 if lines are parallel and overlapping (x, y center)
          0 if intesrection outside segments (x,y set)
         +1 if segments intersect (x,y set)</DL>
</DD>
</DL>
<HR>

<A NAME="findLinePolygonIntersections(double[], double[], double, double, double, double)"><!-- --></A><H3>
findLinePolygonIntersections</H3>
<PRE>
public static double[] <B>findLinePolygonIntersections</B>(double[]&nbsp;x,
                                                    double[]&nbsp;y,
                                                    double&nbsp;x0,
                                                    double&nbsp;y0,
                                                    double&nbsp;x1,
                                                    double&nbsp;y1)</PRE>
<DL>
<DD>Find the intersections between a polygon and a straight line.

 NOTE: This method is only guaranteed to work if the polygon
 is first preprocessed so that "unneccesary" vertices are removed
 (i.e vertices on the straight line between its neighbours).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polygon.<DD><CODE>y</CODE> - Y coordinates of polygon.<DD><CODE>x0</CODE> - X first end point of line.<DD><CODE>x0</CODE> - Y first end point of line.<DD><CODE>x0</CODE> - X second end point of line.<DD><CODE>x0</CODE> - Y second end point of line.
<DT><B>Returns:</B><DD>Intersections [x,y,x,y...].</DL>
</DD>
</DL>
<HR>

<A NAME="createEllipse(int[], int[])"><!-- --></A><H3>
createEllipse</H3>
<PRE>
public static int[] <B>createEllipse</B>(int[]&nbsp;x,
                                  int[]&nbsp;y)</PRE>
<DL>
<DD>Return the geometry of an ellipse based on its four top points.
 Integer domain. The method use the generic createEllipse()
 method for the main task, and then transforms this according
 to any rotation or skew defined by the given top points.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X array of four top points of ellipse.<DD><CODE>y</CODE> - Y array of four top points of ellipse.
<DT><B>Returns:</B><DD>Geometry of ellipse [x,y,x,y...].</DL>
</DD>
</DL>
<HR>

<A NAME="createEllipse(int, int, int, int)"><!-- --></A><H3>
createEllipse</H3>
<PRE>
public static int[] <B>createEllipse</B>(int&nbsp;x0,
                                  int&nbsp;y0,
                                  int&nbsp;dx,
                                  int&nbsp;dy)</PRE>
<DL>
<DD>Create the geometry for an unrotated, unskewed ellipse.
 Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X center of ellipse.<DD><CODE>y0</CODE> - Y center of ellipse.<DD><CODE>dx</CODE> - X ellipse radius.<DD><CODE>dy</CODE> - Y ellipse radius.
<DT><B>Returns:</B><DD>Ellipse geometry [x,y,x,y,...].</DL>
</DD>
</DL>
<HR>

<A NAME="createEllipse(double, double, double, double)"><!-- --></A><H3>
createEllipse</H3>
<PRE>
public static double[] <B>createEllipse</B>(double&nbsp;x0,
                                     double&nbsp;y0,
                                     double&nbsp;dx,
                                     double&nbsp;dy)</PRE>
<DL>
<DD>Create the geometry for an unrotated, unskewed ellipse.
 Floating point domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X center of ellipse.<DD><CODE>y0</CODE> - Y center of ellipse.<DD><CODE>dx</CODE> - X ellipse radius.<DD><CODE>dy</CODE> - Y ellipse radius.
<DT><B>Returns:</B><DD>Ellipse geometry [x,y,x,y,...].</DL>
</DD>
</DL>
<HR>

<A NAME="createCircle(int, int, int)"><!-- --></A><H3>
createCircle</H3>
<PRE>
public static int[] <B>createCircle</B>(int&nbsp;x0,
                                 int&nbsp;y0,
                                 int&nbsp;radius)</PRE>
<DL>
<DD>Create geometry for a circle. Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X center of circle.<DD><CODE>y0</CODE> - Y center of circle.<DD><CODE>radius</CODE> - Radius of circle.
<DT><B>Returns:</B><DD>Geometry of circle [x,y,...]</DL>
</DD>
</DL>
<HR>

<A NAME="createCircle(double, double, double)"><!-- --></A><H3>
createCircle</H3>
<PRE>
public static double[] <B>createCircle</B>(double&nbsp;x0,
                                    double&nbsp;y0,
                                    double&nbsp;radius)</PRE>
<DL>
<DD>Create geometry for a circle. Floating point domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X center of circle.<DD><CODE>y0</CODE> - Y center of circle.<DD><CODE>radius</CODE> - Radius of circle.
<DT><B>Returns:</B><DD>Geometry of circle [x,y,...]</DL>
</DD>
</DL>
<HR>

<A NAME="createSector(int, int, int, int, double, double)"><!-- --></A><H3>
createSector</H3>
<PRE>
public static int[] <B>createSector</B>(int&nbsp;x0,
                                 int&nbsp;y0,
                                 int&nbsp;dx,
                                 int&nbsp;dy,
                                 double&nbsp;angle0,
                                 double&nbsp;angle1)</PRE>
<DL>
<DD>Create the geometry of a sector of an ellipse.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X coordinate of center of ellipse.<DD><CODE>y0</CODE> - Y coordinate of center of ellipse.<DD><CODE>dx</CODE> - X radius of ellipse.<DD><CODE>dy</CODE> - Y radius of ellipse.<DD><CODE>angle0</CODE> - First angle of sector (in radians).<DD><CODE>angle1</CODE> - Second angle of sector (in radians).
<DT><B>Returns:</B><DD>Geometry of secor [x,y,...]</DL>
</DD>
</DL>
<HR>

<A NAME="createSector(int, int, int, double, double)"><!-- --></A><H3>
createSector</H3>
<PRE>
public static int[] <B>createSector</B>(int&nbsp;x0,
                                 int&nbsp;y0,
                                 int&nbsp;radius,
                                 double&nbsp;angle0,
                                 double&nbsp;angle1)</PRE>
<DL>
<DD>Create the geometry of a sector of a circle.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X coordinate of center of ellipse.<DD><CODE>y0</CODE> - Y coordinate of center of ellipse.<DD><CODE>dx</CODE> - X radius of ellipse.<DD><CODE>dy</CODE> - Y radius of ellipse.<DD><CODE>angle0</CODE> - First angle of sector (in radians).<DD><CODE>angle1</CODE> - Second angle of sector (in radians).
<DT><B>Returns:</B><DD>Geometry of secor [x,y,...]</DL>
</DD>
</DL>
<HR>

<A NAME="createArrow(int[], int[], double, double, double)"><!-- --></A><H3>
createArrow</H3>
<PRE>
public static int[] <B>createArrow</B>(int[]&nbsp;x,
                                int[]&nbsp;y,
                                double&nbsp;length,
                                double&nbsp;angle,
                                double&nbsp;inset)</PRE>
<DL>
<DD>Create the geometry of an arrow. The arrow is positioned at the
 end (last point) of the specified polyline, as follows:

                      0,4--,
                         \  --,
                          \    --,
                           \      --,
                            \        --,
    -------------------------3-----------1
                            /        --'
                           /      --'
                          /    --'
                         /  --'
                        2--'
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polyline of where arrow is positioned
                in the end. Must contain at least two points.<DD><CODE>y</CODE> - Y coordinates of polyline of where arrow is positioned
                in the end.<DD><CODE>length</CODE> - Length along the main axis from point 1 to the
                projection of point 0.<DD><CODE>angle</CODE> - Angle between the main axis and the line 1,0
                (and 1,2) in radians.<DD><CODE>inset</CODE> - Specification of point 3 [0.0-1.0], 1.0 will put
                point 3 at distance length from 1, 0.0 will put it
                at point 1.
<DT><B>Returns:</B><DD>Array of the five coordinates [x,y,...].</DL>
</DD>
</DL>
<HR>

<A NAME="createArrow(int, int, int, int, double, double, double)"><!-- --></A><H3>
createArrow</H3>
<PRE>
public static int[] <B>createArrow</B>(int&nbsp;x0,
                                int&nbsp;y0,
                                int&nbsp;x1,
                                int&nbsp;y1,
                                double&nbsp;length,
                                double&nbsp;angle,
                                double&nbsp;inset)</PRE>
<DL>
<DD>Create geometry for an arrow along the specified line and with
 tip at x1,y1. See general method above.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X first end point of line.<DD><CODE>y0</CODE> - Y first end point of line.<DD><CODE>x1</CODE> - X second end point of line.<DD><CODE>y1</CODE> - Y second end point of line.<DD><CODE>length</CODE> - Length along the main axis from point 1 to the
                projection of point 0.<DD><CODE>angle</CODE> - Angle between the main axis and the line 1,0
                (and 1.2)<DD><CODE>inset</CODE> - Specification of point 3 [0.0-1.0], 1.0 will put
                point 3 at distance length from 1, 0.0 will put it
                at point 1.
<DT><B>Returns:</B><DD>Array of the four coordinates [x,y,...].</DL>
</DD>
</DL>
<HR>

<A NAME="createRectangle(int, int, int, int)"><!-- --></A><H3>
createRectangle</H3>
<PRE>
public static int[] <B>createRectangle</B>(int&nbsp;x0,
                                    int&nbsp;y0,
                                    int&nbsp;width,
                                    int&nbsp;height)</PRE>
<DL>
<DD>Create geometry for a rectangle. Returns a closed polygon; first
 and last points matches. Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X corner of rectangle.<DD><CODE>y0</CODE> - Y corner of rectangle.<DD><CODE>width</CODE> - Width (may be negative to indicate leftwards direction)<DD><CODE>height</CODE> - Height (may be negative to indicaten upwards direction)</DL>
</DD>
</DL>
<HR>

<A NAME="createRectangle(double, double, double, double)"><!-- --></A><H3>
createRectangle</H3>
<PRE>
public static double[] <B>createRectangle</B>(double&nbsp;x0,
                                       double&nbsp;y0,
                                       double&nbsp;width,
                                       double&nbsp;height)</PRE>
<DL>
<DD>Create geometry for a rectangle. Returns a closed polygon; first
 and last points matches. Floating point domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X corner of rectangle.<DD><CODE>y0</CODE> - Y corner of rectangle.<DD><CODE>width</CODE> - Width (may be negative to indicate leftwards direction)<DD><CODE>height</CODE> - Height (may be negative to indicaten upwards direction)</DL>
</DD>
</DL>
<HR>

<A NAME="createStar(int, int, int, int, int)"><!-- --></A><H3>
createStar</H3>
<PRE>
public static int[] <B>createStar</B>(int&nbsp;x0,
                               int&nbsp;y0,
                               int&nbsp;innerRadius,
                               int&nbsp;outerRadius,
                               int&nbsp;nArms)</PRE>
<DL>
<DD>Create geometry of a star. Integer domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X center of star.<DD><CODE>y0</CODE> - Y center of star.<DD><CODE>innerRadius</CODE> - Inner radis of arms.<DD><CODE>outerRadius</CODE> - Outer radius of arms.<DD><CODE>nArms</CODE> - Number of arms.
<DT><B>Returns:</B><DD>Geometry of star [x,y,x,y,...].</DL>
</DD>
</DL>
<HR>

<A NAME="createStar(double, double, double, double, int)"><!-- --></A><H3>
createStar</H3>
<PRE>
public static double[] <B>createStar</B>(double&nbsp;x0,
                                  double&nbsp;y0,
                                  double&nbsp;innerRadius,
                                  double&nbsp;outerRadius,
                                  int&nbsp;nArms)</PRE>
<DL>
<DD>Create geometry of a star. Floating point domain.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x0</CODE> - X center of star.<DD><CODE>y0</CODE> - Y center of star.<DD><CODE>innerRadius</CODE> - Inner radis of arms.<DD><CODE>outerRadius</CODE> - Outer radius of arms.<DD><CODE>nArms</CODE> - Number of arms.
<DT><B>Returns:</B><DD>Geometry of star [x,y,x,y,...].</DL>
</DD>
</DL>
<HR>

<A NAME="findPolygonPosition(int[], int[], double, int[])"><!-- --></A><H3>
findPolygonPosition</H3>
<PRE>
public static boolean <B>findPolygonPosition</B>(int[]&nbsp;x,
                                          int[]&nbsp;y,
                                          double&nbsp;length,
                                          int[]&nbsp;position)</PRE>
<DL>
<DD>Return the x,y position at distance "length" into the given polyline.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - X coordinates of polyline<DD><CODE>y</CODE> - Y coordinates of polyline<DD><CODE>length</CODE> - Requested position<DD><CODE>position</CODE> - Preallocated to int[2]
<DT><B>Returns:</B><DD>True if point is within polyline, false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="circleLineIntersection(double, double, double, double)"><!-- --></A><H3>
circleLineIntersection</H3>
<PRE>
public static java.util.List&lt;java.lang.Double&gt; <B>circleLineIntersection</B>(double&nbsp;lineConst,
                                                                      double&nbsp;circleCenter1,
                                                                      double&nbsp;circleCenter2,
                                                                      double&nbsp;circleRadius)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="circleIntersectionWithVerticalLine(double, double, double, double)"><!-- --></A><H3>
circleIntersectionWithVerticalLine</H3>
<PRE>
public static java.util.List&lt;java.lang.Double&gt; <B>circleIntersectionWithVerticalLine</B>(double&nbsp;xLine,
                                                                                  double&nbsp;xCircleCenter,
                                                                                  double&nbsp;yCircleCenter,
                                                                                  double&nbsp;circleRadius)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="circleIntersectionWithHorizontalLine(double, double, double, double)"><!-- --></A><H3>
circleIntersectionWithHorizontalLine</H3>
<PRE>
public static java.util.List&lt;java.lang.Double&gt; <B>circleIntersectionWithHorizontalLine</B>(double&nbsp;yLine,
                                                                                    double&nbsp;xCircleCenter,
                                                                                    double&nbsp;yCircleCenter,
                                                                                    double&nbsp;circleRadius)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="circleIntersectionWithLineSegment(double, double, double, double, double, double, double)"><!-- --></A><H3>
circleIntersectionWithLineSegment</H3>
<PRE>
public static java.util.List&lt;java.lang.Double&gt; <B>circleIntersectionWithLineSegment</B>(double&nbsp;x1,
                                                                                 double&nbsp;y1,
                                                                                 double&nbsp;x2,
                                                                                 double&nbsp;y2,
                                                                                 double&nbsp;xCirc,
                                                                                 double&nbsp;yCirc,
                                                                                 double&nbsp;rCirc)</PRE>
<DL>
<DD>Only intersection with segments that are oriented along x or y axis.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - <DD><CODE>y1</CODE> - <DD><CODE>x2</CODE> - <DD><CODE>y2</CODE> - <DD><CODE>xCirc</CODE> - <DD><CODE>yCirc</CODE> - <DD><CODE>rCirc</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="pointInSegment(double, double, double, double, double, double)"><!-- --></A><H3>
pointInSegment</H3>
<PRE>
public static boolean <B>pointInSegment</B>(double&nbsp;xp,
                                     double&nbsp;yp,
                                     double&nbsp;x1,
                                     double&nbsp;y1,
                                     double&nbsp;x2,
                                     double&nbsp;y2)</PRE>
<DL>
<DD>Only for segments that are oriented along x or y axis.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xp</CODE> - <DD><CODE>yp</CODE> - <DD><CODE>x1</CODE> - <DD><CODE>y1</CODE> - <DD><CODE>x2</CODE> - <DD><CODE>y2</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="pointInRectangle(double, double, double, double, double, double)"><!-- --></A><H3>
pointInRectangle</H3>
<PRE>
public static boolean <B>pointInRectangle</B>(double&nbsp;xp,
                                       double&nbsp;yp,
                                       double&nbsp;x1,
                                       double&nbsp;y1,
                                       double&nbsp;x2,
                                       double&nbsp;y2)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="allIntersectionsOfRectangleAndCircle(double, double, double, double, double, double, double)"><!-- --></A><H3>
allIntersectionsOfRectangleAndCircle</H3>
<PRE>
public static java.util.List&lt;double[]&gt; <B>allIntersectionsOfRectangleAndCircle</B>(double&nbsp;x1,
                                                                            double&nbsp;y1,
                                                                            double&nbsp;x2,
                                                                            double&nbsp;y2,
                                                                            double&nbsp;xCirc,
                                                                            double&nbsp;yCirc,
                                                                            double&nbsp;rCirc)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="getArcsOfCircleInsideRectangle(double, double, double, double, double, double, double)"><!-- --></A><H3>
getArcsOfCircleInsideRectangle</H3>
<PRE>
public static java.util.List&lt;<A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.Arc.html" title="class in cz.agents.alite.planner.spatialmaneuver">GeometryUtils.Arc</A>&gt; <B>getArcsOfCircleInsideRectangle</B>(double&nbsp;x1,
                                                                               double&nbsp;y1,
                                                                               double&nbsp;x2,
                                                                               double&nbsp;y2,
                                                                               double&nbsp;xCirc,
                                                                               double&nbsp;yCirc,
                                                                               double&nbsp;rCirc)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isCircleInsideRectangle(double, double, double, double, double, double, double)"><!-- --></A><H3>
isCircleInsideRectangle</H3>
<PRE>
public static boolean <B>isCircleInsideRectangle</B>(double&nbsp;x1,
                                              double&nbsp;y1,
                                              double&nbsp;x2,
                                              double&nbsp;y2,
                                              double&nbsp;xCirc,
                                              double&nbsp;yCirc,
                                              double&nbsp;rCirc)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="isArc(double[], double[], double, double, double, double, double, double, double)"><!-- --></A><H3>
isArc</H3>
<PRE>
public static boolean <B>isArc</B>(double[]&nbsp;firstPoint,
                            double[]&nbsp;secondPoint,
                            double&nbsp;x1,
                            double&nbsp;y1,
                            double&nbsp;x2,
                            double&nbsp;y2,
                            double&nbsp;xCirc,
                            double&nbsp;yCirc,
                            double&nbsp;rCirc)</PRE>
<DL>
<DD>first point is assumed to be less anticlockwise than the second point
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>firstPoint</CODE> - <DD><CODE>secondPoint</CODE> - <DD><CODE>x1</CODE> - <DD><CODE>y1</CODE> - <DD><CODE>x2</CODE> - <DD><CODE>y2</CODE> - <DD><CODE>xCirc</CODE> - <DD><CODE>yCirc</CODE> - <DD><CODE>rCirc</CODE> - 
<DT><B>Returns:</B><DD></DL>
</DD>
</DL>
<HR>

<A NAME="angleFromCoords(double[])"><!-- --></A><H3>
angleFromCoords</H3>
<PRE>
public static double <B>angleFromCoords</B>(double[]&nbsp;p)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>p</CODE> - double[] {x, y}
<DT><B>Returns:</B><DD>interval &lt;0; 2*PI) (anticlockwise, 0 = {1, 0})</DL>
</DD>
</DL>
<HR>

<A NAME="angleFromCoords(double, double)"><!-- --></A><H3>
angleFromCoords</H3>
<PRE>
public static double <B>angleFromCoords</B>(double&nbsp;x,
                                     double&nbsp;y)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - <DD><CODE>y</CODE> - 
<DT><B>Returns:</B><DD>interval &lt;0; 2*PI) (anticlockwise, 0 = {1, 0})</DL>
</DD>
</DL>
<HR>

<A NAME="angleFromTwoPoints(javax.vecmath.Point3d, javax.vecmath.Point3d)"><!-- --></A><H3>
angleFromTwoPoints</H3>
<PRE>
public static double <B>angleFromTwoPoints</B>(javax.vecmath.Point3d&nbsp;from,
                                        javax.vecmath.Point3d&nbsp;to)</PRE>
<DL>
<DD>Returns an angle of a vector = to - from
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>from</CODE> - <DD><CODE>to</CODE> - 
<DT><B>Returns:</B><DD>interval &lt;0; 2*PI) (anticlockwise, 0 = {1, 0})</DL>
</DD>
</DL>
<HR>

<A NAME="angleBetweenVectors(double, double, double, double)"><!-- --></A><H3>
angleBetweenVectors</H3>
<PRE>
public static double <B>angleBetweenVectors</B>(double&nbsp;fx,
                                         double&nbsp;fy,
                                         double&nbsp;tx,
                                         double&nbsp;ty)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>fx</CODE> - from vector x<DD><CODE>fy</CODE> - from vector y<DD><CODE>tx</CODE> - to vector x<DD><CODE>ty</CODE> - to vector y
<DT><B>Returns:</B><DD>intervals &lt;0; PI>, (-PI; 0&gt;  (anticlockwise, 0 = {1, 0})</DL>
</DD>
</DL>
<HR>

<A NAME="angleFromThreePoints(javax.vecmath.Point3d, javax.vecmath.Point3d, javax.vecmath.Point3d)"><!-- --></A><H3>
angleFromThreePoints</H3>
<PRE>
public static double <B>angleFromThreePoints</B>(javax.vecmath.Point3d&nbsp;apex,
                                          javax.vecmath.Point3d&nbsp;from,
                                          javax.vecmath.Point3d&nbsp;to)</PRE>
<DL>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>apex</CODE> - <DD><CODE>from</CODE> - <DD><CODE>to</CODE> - 
<DT><B>Returns:</B><DD>intervals &lt;0; PI>, (-PI; 0&gt;  (anticlockwise, 0 = {1, 0})</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GeometryUtils.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/DebugTextZoneVisitor.html" title="class in cz.agents.alite.planner.spatialmaneuver"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../../../cz/agents/alite/planner/spatialmaneuver/GeometryUtils.AntiClockWiseComparator.html" title="class in cz.agents.alite.planner.spatialmaneuver"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../../index.html?cz/agents/alite/planner/spatialmaneuver/GeometryUtils.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GeometryUtils.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;<A HREF="#nested_class_summary">NESTED</A>&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
