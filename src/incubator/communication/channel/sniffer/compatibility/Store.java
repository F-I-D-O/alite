package incubator.communication.channel.sniffer.compatibility;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.Serializable;
import java.util.logging.Logger;
import java.util.zip.CRC32;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import java.util.zip.ZipOutputStream;


/**
 * <p>Title: A-Globe</p>
* <p>Description: Serves as a movable permanent storage for an agent or other platform component. In fact encapsulates a
 * directory in which the files are stored. When agent migrates its store is moved with him to the new location.</p>
 * <p>Copyright: Copyright (c) 2003</p>
 * <p>Company: Gerstner Laboratory</p>
 * @author David Sislak
 * @version $Revision: 1.1 $ $Date: 2008/02/28 12:58:06 $
 *
 */
// TODO: complete the javadoc

public final class Store {
  /**
   * Agent home directory
   */
  private final String agentHome;

  /**
   * Service home directory
   */
  private final String serviceHome;

  /**
   * Library home directory
   */
  private final String libHome;

  /**
   * Preferences home directory
   */
  private final String prefHome;

  /**
   * The file in the root of the storage directory where will be placed READMETXT information.
   */
  public static final String READMEF = "readme.txt";

  /**
   * Information for the READMEF file.
   */
  public static final String READMETXT =
      "This directory was generated by the A-Globe"
      + System.getProperty("line.separator")
      +
      "All container persistent information and configuration are stored here.";

  /**
   * Init buffer length
   */
  private final static int BUFLEN = 1024;

  /**
   * Root store
   */
  private String Root = null;

  /**
   *
   * @param containerName String - name of the container
   * @param storeRoot String - path to the store root directory, if null it is used default path dependent on the host OS
   */
  public Store(String containerName, String storeRoot) {
    String containerHome;
    if (storeRoot == null)
//      containerHome = System.getProperty("user.home") + File.separator +
//        ".container" + File.separator + containerName;
    containerHome = "." + File.separator +
          ".container" + File.separator + containerName;
     else
      containerHome = storeRoot + File.separator + containerName;

    agentHome = containerHome + File.separator + "agents";
    serviceHome = containerHome + File.separator + "services";
    libHome = containerHome + File.separator + "libraries";
    prefHome = containerHome + File.separator + "prefs";

    Root = containerHome;

    if (!exist(READMEF)) {
      Logger.getLogger("Store").info("Initializing container store: " +
                                     containerHome);
      putString(READMEF, READMETXT);
    }
  }

  /**
   * Define that this store will be store for the agent with name 'agentname'
   * @param agentname String
   */
  public void setAsAgentStore(String agentname) {
    Root = agentHome + File.separator + agentname;
  }

  /**
   * Define that this store will be store for the service with name 'agentname'
   * @param servicename String
   */
  public void setAsServiceStore(String servicename) {
    Root = serviceHome + File.separator +
        servicename.replace('.', File.separatorChar);
  }

  /**
   * Define that this store will be store for Libraries
   */
  public void setAsLibraryStore() {
    Root = libHome;
  }

  /**
   * Define that this store will be global store for kernel purposes
   */
  public void setAsGlobalStore() {
    Root = prefHome;
  }

  /**
   * This method should be used only by container core classes.
   * Namely LibraryManager uses it to find absolute path of libraries to
   * add/remove them from ClassPath.
   *
   * @param key - The key to return the apsolute path for
   * @return The path
   */
  public String getAbsolutePath(String key) {
    return Root + File.separator + key;
  }

  /**
   * Put string value to the store
   * @param key String - key for the value
   * @param value String
   */
  public void putString(String key, String value) {
    try {
      // don't allow them to write to other dirs
      if (key.indexOf("..") != -1) {
        Logger.getLogger("Store").severe("Store: Illegal write attempt, key: " +
                                         key);
        return;
      }

      String file = Root + "/" + key;
      CreateFileWithPath(file);
      FileOutputStream fos = new FileOutputStream(file);
      OutputStreamWriter osw = new OutputStreamWriter(fos);
      try {
        fos.getChannel().lock(0L, Long.MAX_VALUE, false);
      }
      catch (Exception ex1) {
        ex1.printStackTrace();
      }
      osw.write(value);
      osw.close();
//      FileWriter f = new FileWriter(file);
//      f.write(value);
//      f.close();
    }
    catch (Exception ex) {
    }
  }

  /**
   * Put int value to the store
   * @param key String - key for the value
   * @param value int
   */
  public void putInt(String key, int value) {
    putString(key, String.valueOf(value));
  }

  /**
   * Put double value to the store
   * @param key String - key for the value
   * @param value double
   */
  public void putDouble(String key, double value) {
    putString(key, String.valueOf(value));
  }

  /**
   * Put boolean value to the store
   * @param key String - key for the value
   * @param value boolean
   */
  public void putBoolean(String key, boolean value) {
    putString(key, String.valueOf(value));
  }

  /**
   * Put object value to the store. Object must be serializable.
   * @param key String - key fot the object
   * @param value Serializable
   */
  public void putObject(String key, Serializable value) {
    OutputStream o = putFile(key);
    if (o != null) {
      try {
        ObjectOutputStream out = new ObjectOutputStream(o);
        out.writeObject(value);
        out.close();
      }
      catch (IOException ex) {
        ex.printStackTrace();
      }
    }
  }

  /**
   * Test if there is some value for the key
   * @param key String
   * @return boolean - true iff there is some value asociated with the key
   */
  public boolean exist(String key) {
    File f = new File(Root + File.separator + key);
    return f.exists();
  }

  /**
   * Put onw file to the store
   * @param key String - the file will be asociated with the key
   * @return FileOutputStream - output stream for the created file; returns null iff file asociated with key
   * could not be created or aleready exists
   */
  public FileOutputStream putFile(String key) {
    try {
      // new file truncated to 0 size
      String file = Root + File.separator + key;
      CreateFileWithPath(file);
      FileOutputStream f = new FileOutputStream(new File(file).getAbsolutePath());
      try {
        f.getChannel().lock(0L, Long.MAX_VALUE, false);
      }
      catch (Exception ex1) {
      }
      return f;
    }
    catch (Exception ex) {
      return null;
    }
  }

  /**
   * Remove stored file asociated with the key
   *
   * @param key String
   * @return boolean - true iff file was successfully deleted
   */
  public boolean removeFile(String key) {
    try {
      String file = Root + File.separator + key;
      file = file.trim();
      File f = new File(file);
      if (f.exists()) {
        return f.delete();
      }
      return true;
    }
    catch (Exception ex) {
      Logger.getLogger("Store").severe("Store: Couldn't remove file.");
      return false;
    }
  }

  /**
   * Put marshallable object to the store in the XML format
   * @param key String - key for the object m
   * @param m MarshallableRootElement - object which will be stored in the store
   */
//  public void putXML(String key, MarshallableRootElement m) {
//    try {
//      FileOutputStream out = putFile(key);
//      try {
//        out.getChannel().lock(0L, Long.MAX_VALUE, false);
//      }
//      catch (Exception ex1) {
//      }
//      if (out != null) {
//        m.validate();
//        m.marshal(out);
//        out.close();
//      }
//    }
//    catch (Exception ex) {
//      ex.printStackTrace();
//    }
//  }

  /**
   * Get value asociated with the key as a string value
   * @param key String
   * @return String - returns null if there isn't any value asociated with key
   */
  private String getString(String key) {
    if (key.indexOf("..") != -1)
      return null;

//    FileReader f = null;
//    BufferedReader b = null;

    try {
      FileInputStream fis = new FileInputStream(Root + File.separator + key);
      try {
        fis.getChannel().lock(0L, Long.MAX_VALUE, true);
      }
      catch (Exception ex1) {
        ex1.printStackTrace();
      }

      BufferedReader d
          = new BufferedReader(new InputStreamReader(fis));
      String s = d.readLine();
      d.close();

//      f = new FileReader(Root + File.separator + key);
//      b = new BufferedReader(f);
//      String s = b.readLine();
//      b.close();
//      f.close();
      return s;
    }
    catch (Exception ex) {
      return null;
    }
  }

  /**
   * Get value asociated with the key as a string value. Caller specifies default value for the key.
   * @param key String
   * @param def String - this value will be returned if there isn't any value asociated with the key. If there isn't any
   * value it will be also stored to this key
   * @return String
   */
  public String getString(String key, String def) {
    String d = getString(key);
    if (d == null) {
      putString(key, def);
      return def;
    }
    else
      return d;
  }

  /**
   * Get value asociated with the key as a int value. Caller specifies default value for the key.
   * @param key String
   * @param def int - this value will be returned if there isn't any value asociated with the key. If there isn't any
   * value it will be also stored to this key
   * @return int
   */
  public int getInt(String key, int def) {
    try {
      return Integer.parseInt(getString(key));
    }
    catch (Exception ex) {
      putInt(key, def);
      return def;
    }
  }

  /**
   * Get value asociated with the key as a double value. Caller specifies default value for the key.
   * @param key String
   * @param def double - this value will be returned if there isn't any value asociated with the key. If there isn't any
   * value it will be also stored to this key
   * @return int
   */
  public double getDouble(String key, double def) {
    try {
      return Double.parseDouble(getString(key));
    }
    catch (Exception ex) {
      putDouble(key, def);
      return def;
    }
  }

  /**
   * Get value asociated with the key as a boolean value. Caller specifies default value for the key.
   * @param key String
   * @param def boolean - this value will be returned if there isn't any value asociated with the key. If there isn't any
   * value it will be also stored to this key
   * @return boolean
   */
  public boolean getBoolean(String key, boolean def) {
    String s = getString(key);
    if (s == null) {
      putBoolean(key, def);
      return def;
    }

    if (s.equalsIgnoreCase("true"))
      return true;
    else if (s.equalsIgnoreCase("false"))
      return false;
    else
      return def;
  }

  /**
   * Get value asociated with the key as a object
   *
   * @param key String
   * @param classLoader ClassLoader -
   * @return Object - deserialized object from the file. If there is some
   *   problem with deserialization, returns null
   */
  public Object getObject(String key, ClassLoader classLoader) {
    InputStream i = getFile(key);
    if (i != null) {
      try {
        ObjectInputStream in = new LibraryObjectInputStream(i, classLoader);
        Object o = in.readObject();
        in.close();
        return o;
      }
      catch (Exception ex) {
        ex.printStackTrace();
      }
    }

    return null;
  }

  /**
   * Get file asociated with the key
   * @param key String
   * @return FileInputStream - input stream for file asociated with key. Returns null iff file doesn't exists or cannot be
   * opened
   */
  public FileInputStream getFile(String key) {
    try {
      FileInputStream f = new FileInputStream(new File(Root + "/" + key).
                                              getAbsolutePath());
      try {
        f.getChannel().lock(0L, Long.MAX_VALUE, true);
      }
      catch (Exception ex1) {
      }
      return f;
    }
    catch (Exception ex) {
      return null;
    }
  }

  /**
   * Get XML value asociated with the key as a object
   * @param key String
   * @param c Class - object to which XML formated file will be unmarshalled
   * @throws Exception - throws exception if there is some problem with unmarshalling or opening the file
   * @return Object - unmarshalled object
   */
  public Object getXML(String key, Class c) throws Exception {
    FileInputStream in = getFile(key);
    Object o = c.getMethod("unmarshal", new Class[] {InputStream.class}).invoke(null,
        new Object[] {in});
    in.close();
    return o;
  }

  /**
   * Returns list of the members of the specified directory denoted by the key
   * @param key String
   * @return String[] - null if the key doesn't specify the directory
   */
  public String[] listEntries(String key) {
    File f = new File(Root + File.separator + key);
    String[] l = f.list();
    if (l == null)
      return new String[0];
    else
      return l;
  }

  /**
   * Internal method used for creating storage file for specified key
   * @param key String
   * @throws StoreException
   */
  synchronized private void CreateFileWithPath(String key) throws
      StoreException {
    File f = new File(key);

    if (!f.getParentFile().exists())
      f.getParentFile().mkdirs();

    try {
      if (!f.exists())
        f.createNewFile();
    }
    catch (Exception ex) {
      ex.printStackTrace();
      Logger.getLogger("Store").severe("Store: Couldn't create file: "+key);
      throw new StoreException();
    }
  }

  /**
   * Remove asociated value from the key
   * @param key String
   */
  public void deleteKey(String key) {
    delete(Root + File.separator + key);
  }

  /**
   * Remove asociated value from the key. If key specify the directory, whole directory will be erased.
   * @param key String
   */
  private void delete(String key) {
    File f = new File(key);

    if (f.isDirectory()) {
      String files[] = f.list();
      for (int i = 0; i < files.length; i++)
        delete(key + File.separator + files[i]);
    }

    f.delete();
  }

  /**
   * Zip whole store storage to the zip archive and output archive to the output stream. This function
   * is used for store migration
   * @param out OutputStream
   */
  public void zip(OutputStream out) {
    File f = new File(Root);

    File subs[] = f.listFiles();
    if (subs != null) {
      ZipOutputStream zip = new ZipOutputStream(out);
      for (int i = 0; i < subs.length; i++)
        addToZip("", subs[i], zip);

      try {
        zip.finish();
      }
      catch (Exception ex) {
        ex.printStackTrace();
      }
    }
  }

  /**
   * Unzip archive read from the input stream to the store storage. This function
   * is used for store migration
   * @param in InputStream
   */
  public void unZip(InputStream in) {
    byte buf[] = new byte[BUFLEN];
    int len;

    try {
      ZipInputStream zip = new ZipInputStream(in);
      ZipEntry e;
      while ( (e = zip.getNextEntry()) != null) {
        if (e.isDirectory()) { // Create directory
          File f = new File(Root + File.separator + e.getName());
          f.mkdirs();
        }
        else { // Create parent directory
          File f = new File(Root + File.separator + e.getName());
          f.getParentFile().mkdirs();

          try {
            FileOutputStream out = new FileOutputStream(f);
            CRC32 crc32 = new CRC32();
            while ( (len = zip.read(buf)) != -1) {
              crc32.update(buf, 0, len);
              out.write(buf, 0, len);
            }
            out.close();

            f.setLastModified(e.getTime());

            if (e.getCrc() != crc32.getValue())
              throw new RuntimeException("CRC32 error for file: " + e.getName());
          }
          catch (FileNotFoundException ex) {
            ex.printStackTrace();
          }
        }
      }
    }
    catch (IOException ex) {
      ex.printStackTrace();
    }
  }

  /**
   * Internal method used for zipping the store storage
   * @param path String
   * @param f File
   * @param zip ZipOutputStream
   */
  private void addToZip(String path, File f, ZipOutputStream zip) {
    String name = path + f.getName();
    if (f.isDirectory())
      name = name + "/";

    try {
      ZipEntry e = new ZipEntry(name);
      e.setTime(f.lastModified());

      if (f.isFile()) {
        final int STORELIMIT = 100;
        byte buf[] = new byte[BUFLEN];
        int len;

        // Calculate the CRC32
        CRC32 crc32 = new CRC32();
        FileInputStream in = new FileInputStream(f.getAbsolutePath());
        while ( (len = in.read(buf)) != -1)
          crc32.update(buf, 0, len);
        in.close();

        e.setSize(f.length());
        e.setCrc(crc32.getValue());
        if (f.length() < STORELIMIT) // Use store for small files.
          e.setMethod(ZipEntry.STORED);

        zip.putNextEntry(e);
        // Compress the file
        in = new FileInputStream(f.getAbsolutePath());
        while ( (len = in.read(buf)) != -1)
          zip.write(buf, 0, len);
        in.close();
      }
      else { // Directory - add contents
        zip.putNextEntry(e);
        File subs[] = f.listFiles();
        for (int i = 0; i < subs.length; i++)
          addToZip(name, subs[i], zip);
      }
    }
    catch (Exception ex) {
      ex.printStackTrace();
    }
  }

}
