package incubator.visprotocol.creator;

import incubator.visprotocol.processor.MultiplePuller;
import incubator.visprotocol.processor.Once;
import incubator.visprotocol.processor.StateGetter;
import incubator.visprotocol.processor.StructProcessor;
import incubator.visprotocol.processor.updater.DiffUpdater;
import incubator.visprotocol.processor.updater.Differ;
import incubator.visprotocol.processor.updater.MergeUpdater;
import incubator.visprotocol.protocol.FileReaderProtocol;
import incubator.visprotocol.protocol.FileWriterProtocol;
import incubator.visprotocol.protocol.MemoryProtocol;
import incubator.visprotocol.protocol.StreamProtocolCloser;
import incubator.visprotocol.sampler.MaxFPSRealTimeSampler;
import incubator.visprotocol.structure.key.Vis2DCommonKeys;
import incubator.visprotocol.vis.layer.FilterStorage;
import incubator.visprotocol.vis.layer.common.FillColorLayer;
import incubator.visprotocol.vis.layer.common.Vis2DInfoLayer;
import incubator.visprotocol.vis.layer.example.BrainzLayer;
import incubator.visprotocol.vis.layer.example.LightsLayer;
import incubator.visprotocol.vis.layer.example.PentagramLayer;
import incubator.visprotocol.vis.layer.example.ScreenTextLayer;
import incubator.visprotocol.vis.layer.example.SimInfoLayer;
import incubator.visprotocol.vis.layer.example.ZombieLayer;
import incubator.visprotocol.vis.output.Vis2DOutput;
import incubator.visprotocol.vis.output.Vis2DParams;
import incubator.visprotocol.vis.output.painter.TreePainter;
import incubator.visprotocol.vis.output.vis2d.Vis2DBasicTransformators;
import incubator.visprotocol.vis.output.vis2d.painter.Vis2DBasicPainters;
import incubator.visprotocol.vis.player.Player;
import incubator.visprotocol.vis.player.ui.PlayerControls;

import java.awt.Color;
import java.awt.geom.Rectangle2D;
import java.io.File;
import java.util.ArrayList;
import java.util.Random;

import javax.vecmath.Point3d;

import cz.agents.alite.creator.Creator;

/**
 * Example creator for vis protocol. Has 3 modes:
 * 
 * Protocol: Difference from last state is generated by layers. The difference is sent through
 * protocol, then last state on the other side is updated by the differences. Current state is
 * painted.
 * 
 * Realtime: State is merged from layers, the state is painted.
 * 
 * Direct: Layers draw directly to output, no state storing.
 * 
 * @author Ondrej Milenovsky
 * */
public class TestCreator implements Creator {

    private static final int DELAY = 20;
    private ExampleEnvironment exampleEnvironment;
    private Vis2DOutput vis2d;
    private StructProcessor root;

    @Override
    public void init(String[] args) {
    }

    @Override
    public void create() {
        createEnvironment();
        createAndRunVis();
        createAndRunSimulation();
    }

    private void createEnvironment() {
        exampleEnvironment = new ExampleEnvironment();
    }

    private void createAndRunVis() {
        Vis2DParams params = new Vis2DParams();
        params.worldBounds = new Rectangle2D.Double(-400, -600, 11000, 11000);
        vis2d = new Vis2DOutput(params);
        vis2d.addTransformators(Vis2DBasicTransformators.createBasicTransformators());

        // TODO bug kdyz je protocol, u dynamickych bodu se obcas neprepisou parametry

        // V realtime modu je to tak 3x rychlejsi nez protocol. Direct este rychlejsi, ale nema
        // ulozenej aktualni stav, hodne trhane dokaze i 1M bodu. Kdyz je direct, tak se z proxy
        // musi generovat body pokazdy, u ostatnich staci jednou na zacatku.
        final Mode mode = Mode.PROTOCOL;
        // 100k se trochu trha, 200k se dost trha, 1M u protocolu dosla pamet
        int nDynamicPoints = 1000;
        // staticky body, tech to zvladne hodne, tady je direct nejpomalejsi
        int nStaticPoints = 10000;

        // filter
        FilterStorage filter = new FilterStorage(Vis2DBasicPainters.ELEMENT_TYPES,
                Vis2DCommonKeys.COMMON_PARAMS);
        // layers
        ArrayList<StructProcessor> layers = new ArrayList<StructProcessor>();
        layers.add(new SimInfoLayer(exampleEnvironment, filter));
        if (mode == Mode.DIRECT) {
            layers.add(new FillColorLayer(Color.BLACK, ".Undead land.Background", filter));
        } else {
            layers
                    .add(new Once(
                            new FillColorLayer(Color.BLACK, ".Undead land.Background", filter)));
        }
        layers.add(new PentagramLayer(exampleEnvironment, filter));
        if (mode == Mode.DIRECT) {
            layers.add(new BrainzLayer(nStaticPoints, 10000, filter));
        } else {
            layers.add(new Once(new BrainzLayer(nStaticPoints, 10000, filter)));
        }
        layers.add(new LightsLayer(nDynamicPoints, 10000, filter));
        layers.add(new ZombieLayer(exampleEnvironment, filter));
        layers.add(new ScreenTextLayer(exampleEnvironment, filter));
        StructProcessor visInfoLayer = new Vis2DInfoLayer(vis2d, filter);

        // create the structure of processors
        TreePainter painter = null;
        StreamProtocolCloser streamCloser = new StreamProtocolCloser();
        if (mode == Mode.DIRECT) {
            layers.add(visInfoLayer);
            painter = new TreePainter(layers);
            root = vis2d;
        } else if (mode == Mode.REALTIME) {
            MergeUpdater updater = new MergeUpdater(layers);
            painter = new TreePainter(updater, visInfoLayer);
            root = vis2d;
        } else if ((mode == Mode.PROTOCOL) || (mode == Mode.SAVE_TO_FILE)) {
            Differ differ = new Differ(layers);
            MemoryProtocol protocol = new MemoryProtocol(differ);
            DiffUpdater updater = new DiffUpdater(protocol);
            painter = new TreePainter(updater, visInfoLayer);
            root = vis2d;
        } else if (mode == Mode.SAVE_TO_FILE) {
            Differ differ = new Differ(layers);
            FileWriterProtocol fwp = new FileWriterProtocol(new File("record.grr"),
                    new StateGetter(differ));
            streamCloser.addStreamProtocol(fwp);
            painter = new TreePainter(differ, visInfoLayer);
            root = new MultiplePuller(vis2d, fwp);
        } else if (mode == Mode.PLAYER_FROM_FILE) {
            FileReaderProtocol frp = new FileReaderProtocol(new File("record.grr"));
            streamCloser.addStreamProtocol(frp);
            Player player = new Player(frp);
            painter = new TreePainter(new StateGetter(player), visInfoLayer);
            vis2d.addTransformator(new PlayerControls(player));
            root = vis2d;
        }

        painter.addPainters(Vis2DBasicPainters.createBasicPainters(vis2d));
        vis2d.addInput(painter);
        vis2d.setStreamCloser(streamCloser);

        // sampler
        MaxFPSRealTimeSampler sampler = new MaxFPSRealTimeSampler() {
            @Override
            protected void sample() {
                root.pull();
            }
        };
        sampler.start();
    }

    private void createAndRunSimulation() {
        Random random = new Random();
        while (true) {
            exampleEnvironment.examplePosition = new Point3d(random.nextDouble() * 200.0 + 100.0,
                    random.nextDouble() * 200.0 + 100.0, random.nextDouble() * 20.0 + 100.0);
            exampleEnvironment.exampleInteger = random.nextInt(256);

            exampleEnvironment.exampleTime += DELAY;

            try {
                Thread.sleep(DELAY);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static class ExampleEnvironment implements ZombieProvider {

        private long exampleTime = 1;

        private String exampleString = "Green zombie";
        private Point3d examplePosition = new Point3d();
        private int exampleInteger = 100;

        @Override
        public String getPersonName() {
            return exampleString;
        }

        @Override
        public Point3d getPersonPosition() {
            return examplePosition;
        }

        @Override
        public int getPersonHealth() {
            return exampleInteger;
        }

        public long getTime() {
            return exampleTime;
        }

    }

    private enum Mode {
        /** proxies -> differ -> protocol -> updater -> painter */
        PROTOCOL,
        /** proxies -> updater -> painter */
        REALTIME,
        /** proxies -> painter, but the current state is not stored */
        DIRECT,
        /** protocol + save to file */
        SAVE_TO_FILE,
        /** no environment, player from file */
        PLAYER_FROM_FILE,
    }

}
